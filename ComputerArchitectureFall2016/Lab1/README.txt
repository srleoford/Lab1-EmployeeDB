	In this lab, we were to create database system using the binary tree data structure to store employee names. There was to be operations such as add employee, remove employee, and list/print all the names in the database. In the Lab1 folder, there is the binaryTree.h that declares the majority of the operations for the lab, insertion, deletion, and so on. It also has the some macors for the length of the employee name and memory allocation for employee, rather than typing the full command out every time, and an errorCheck I can insert into various lines in the programs to help me debug and understand where the problems were in the program. Also, to make matters simpler, I declared the struct "employee" to include the employee name, a left child, and a right child to instigate the binary search tree. In retrospect, I probably should've included an "employeeTree" structure to keep track of the root of the entire tree rather than declaring a single employee to carry that burden.
	In the employeeList file, I defined all the operations for the database. The "tFree" method would recursively free all memory allocation for all the leaves and the root. The "printNames" method would simply print a nice header for the list then call "printInOrder" to print all the employee names recursively. "printInOrder" will recursively go through the root's left child leaves and print them, print the root, and then print it's right child leaves. "insertEmployee" was unfortunately one I was not able to completely fix. The code will check if the root is null and if it is then insert the new employee into the root then end. If not, it will compare the current's employee name to the root's employee name and check if the name is "less" than the root or bigger, check if the respective child is null, and if not, recursively call the method with the root's respective child until it finds an empty place for it and inserts. Unfortunately my program kept replacing the root and I couldn't figure out why. The "deleteEmployee" method wasn't finished since I spent too much time trying to fix the "insertEmployee" method, but the idea was similair to the search method for it. It would search for the employee to delete, replace it with it's left child's "biggest name" or it's right child's "smallest" name.
	The "employeeDBDemo" file was a little tricky. It was the basic interface for the user. It used a giant "while" loop to keep repeating for the user until they were completely done with the database. Inside the loop, it used a switch and only checked for the first letter of every response, since the responses were unique enough to warrant the check of a single character. Each switch corresponded to each operation needed for the database and then would eventually end with a yes or no to end the loop.
